{"cells":[{"metadata":{},"cell_type":"markdown","source":"# Définition, création et exploitation d'une liste\n\nUne liste est une structure de données qui contient une série de valeurs. Python autorise la construction de listes contenant des valeurs de types différents (par exemple entier et chaîne de caractères), ce qui leur confère une grande flexibilité. Une liste est déclarée par une série de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de chaînes de caractères) séparées par des virgules, et le tout encadré par des crochets.\n\n#### Exemples : "},{"metadata":{"trusted":true},"cell_type":"code","source":"liste1=[5,5.2,-3,23/9.81,\"Bonjour\",[1,2,3],True] ## Cette liste contient 7 éléments\nliste2=[] ## Cette liste ne contient aucun élément. C'est une liste vide. \n# Une autre façon de l'écrire est :\nliste2=list()","execution_count":1,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"#### Création d'une liste\n\nIci, on souhaite créer une liste avec les éléments suivants _\"B\",\"o\",\"n\",\"j\",\"o\",\"u\",\"r\"_. Pour créer directement une liste, il existe plusieurs possibilités.\n\n1. Tout d'abord, on peut renseigner les éléments directement en créant la liste.\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste=[\"B\",\"o\",\"n\",\"j\",\"o\",\"u\",\"r\"]","execution_count":2,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"2. Une autre façon de faire est de créer une liste vide et d'ajouter les éléments au fur et à mesure. Cette façon de créer la liste est très intéressante lorsque les éléments ne sont pas connus à l'avance et qu'ils sont par exemple issu d'un calcul."},{"metadata":{"trusted":true},"cell_type":"code","source":"liste=[]\nfor i in \"Bonjour\":\n    liste=liste+[i]","execution_count":3,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"La commande _liste=liste+[i]_ est une commande de __concaténation__ de deux listes. L'opération de concaténation correspond à une opération d'assemblage entre deux éléments. \n\nSi _liste1=[1,2]_ et _liste=[4,3]_ alors _liste1+liste2_ vaut _[1,2,4,3]_\n\nUne syntaxe alternative consiste à utiliser la méthode _.append()_ pour ajouter un élément à la fin de la liste. Ainsi la commande _liste = liste + [i]_ génére le même résultat sur la commande _liste.append(i)_ (à une subtilité près que l'on précise à la fin du notebook)\n\n# ATTENTION :\n\nLa commande _liste.append(i)_ modifie _liste_ et ne renvoie pas de résultat, ainsi la commande _liste = liste.append(i)_ reviendrait à \n\n(1) modifier liste en ajoutant i, \n\npuis (2) à récupérer le résultat de cette opération (qui vaut 'rien' puisque la méthode ne renvoie rien) et à stocker ce résultat dans liste. Donc la liste ne contient rien!\n\nCette syntaxe _liste = liste.append(...)_ est donc à bannir !!!\n\n## Exemples d'application :\n\nSoient les listes suivantes _liste1=[1,2,\"Bon\"]_ et _liste2=[3,4]_ . Construisez alors une _liste3_ à l'aide des _liste1_ et _liste2_ de façon à obtenir\n1. liste3=[1,2,\"Bon\",3,4]\n2. liste3=[3,4,1,2,\"Bon\"]\n3. liste3=[1,2,\"Bon\",[3,4]]\n4. liste3=[[1,2,\"Bon\"],[3,4]]\n5. liste3=[[1,2,\"Bon\",3,4]]\n6. liste3=[1,2,\"Bon\",5,3,4]}"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste1 = [1,2,\"Bon\"]\nliste2 = [3,4]\n# A compléter\n","execution_count":4,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"3. Une troisième façon est de créer la liste par __compréhension__. Il s'agit essentiellement d'un raccourci souvent utilisé dans les codes que vous lirez dans votre vie de scientifique. La syntaxe est de la forme :\n\n_liste = [i for i in iterable]_\n\nOù _iterable_ est un objet que l'on peut parcourir (en Python, il y a les listes, les chaines de caractères mais également d'autres objets que nous verrons plus tard).\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = [lettre for lettre in \"Bonjour\"]\nprint(liste)","execution_count":5,"outputs":[{"output_type":"stream","text":"['B', 'o', 'n', 'j', 'o', 'u', 'r']\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"_Remarque_ : Dans une définition par compréhension, on peut ajouter des conditions pour ne conserver les éléments de l'itérable vérifiant cette condition"},{"metadata":{"trusted":true},"cell_type":"code","source":"voyelles = 'aeiouy'\nliste_v = [lettre for lettre in \"Bonjour\" if lettre in voyelles]\nprint(liste_v)","execution_count":6,"outputs":[{"output_type":"stream","text":"['o', 'o', 'u']\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"On peut notamment utiliser l'instruction _range(...)_ pour générer une liste d'entiers. _range_ fonctionne différemment selon le nombre d'arguments :  \n\n1. _range(n)_ est un itérable qui contient tous les entiers de 0 inclu à _n_ exclu en allant de 1 en 1\n2. _range(début,fin)_ contient tous les entiers de _début_ inclu à _fin_ exclu en allant de 1 en 1\n3. _range(début,fin,pas)_ contient tous les entiers de _début_ inclu à _fin_ exclu en allant de _pas_ en _pas_"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = [i for i in range(7)]\nprint(liste)\nliste_pairs = [i for i in range(-5,5) if i%2==0] \nprint(liste_pairs)","execution_count":7,"outputs":[{"output_type":"stream","text":"[0, 1, 2, 3, 4, 5, 6]\n[-4, -2, 0, 2, 4]\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"## Exemples d'application\n\nCréer par compréhension les listes suivantes : \n1. [1,3,5,7,9] liste des 5 premiers nombres impairs\n2. [0,10,20,30,40] liste des 5 premiers nombres divisible par 10\n3. [0,1,4,9,16,25] liste des 6 premiers nombres au carré\n4.  L=[3,6,9,12,15,18,21,24], créez la liste [12,18,24] qui correspond aux nombres de _L_ qui sont  divisibles à la fois par 2 et par 3 et dont le carré est supérieur à 100."},{"metadata":{"trusted":true},"cell_type":"code","source":"# A compléter","execution_count":8,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Une quatrième façon (moins utilisée en pratique) est de créer la liste en modifiant le typage d'un autre objet itérable :"},{"metadata":{"trusted":true},"cell_type":"code","source":"chaine=\"Bonjour\"\nliste=list(chaine)\nprint(liste)","execution_count":9,"outputs":[{"output_type":"stream","text":"['B', 'o', 'n', 'j', 'o', 'u', 'r']\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"### Accès à une valeur d'une liste \n\nSi l'on veut accéder à une valeur d'une liste, il suffit de connaître son index (c'est-à-dire sa position au sein de la liste). On récupère alors la valeur voulue à l'aide de la commande _L[index]_ (_L_ étant une liste).\n\n__Exemple__ : On définit la liste suivante _L=[5,5.2,-3,23/9.81,\"Bonjour\",[1,2,3],True]_ \n* L[0] renvoie alors 5\n* L[1] renvoie alors 5.2\n* L[2] renvoie alors -3\n* L[3] renvoie alors 2.3445463812\n* L[4] renvoie alors \"Bonjour\"\n* L[5] renvoie alors [1,2,3]\n* L[6] renvoie alors True\n\n_Remarque 1_ : L'indexation du premier élément se fait avec l'indice 0.\n\n_Remarque 2_ : On peut également indexer par des nombres négatifs : L[-1] correspond au dernier élément.\n\n## Le cas des listes imbriquées\n\nLorsque une liste contient elle même une liste ou objet indiçable (chaine de caractère par exemple), on peut directement accéder à un élément particulier de l'objet imbriqué : prenons un exemple\n\nL = [\"Bonjour\", \"comment\", \"allez\", \"vous\"]\n\nOn peut accéder au i-ème mot avec la commande mot_i = L[i], une fois ce mot extrait on peut accèder au j-ème caractère avec la commande lettre_j = mot_i[j].\n\nAu final, on peut directement extraire cette lettre avec la commande \n\n__lettre_j = L[i][j]__\n\nEn réalité python interprète le code de gauche à droite et donc on peut expliquer ce qui se passe en mettant des parenthèses :\n\n__lettre_j = (L[i])[j]__\n\nOn commence donc par extraire le i-ème mot (exécution de la parenthèse) et on extrait le j-ème élément du résultat ce qui revient bien à faire les deux étapes précédemment décrites.\n\n#### Exemples d'application :\n\n1. A partir de la liste L = [\"Bonjour\", \"comment\", \"allez\", \"vous\"], faire un programme qui construit une liste L_1 qui contient la liste des premières lettre de chaque mot de L \n\nLe résultat sera donc [\"B\",\"c\",\"a\",\"v\"]\n\nFaire de même avec un programme qui construit la liste L_123 des sous-mots constitués des 3 premières lettres de chaque mot (le résultat sera donc [\"Bon\",\"com\",\"all\",\"vou\"])"},{"metadata":{"trusted":true},"cell_type":"code","source":"L = [\"Bonjour\", \"comment\", \"allez\", \"vous\"]\n#A compléter\n","execution_count":10,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"2. Soit la liste L=[5,5.2,-3,23/9.81,\"Bonjour\",[1,2,3],True], prévoir les résultats que renvoient les commandes suivantes et justifiez le résultat obtenu : \n\nL[-7]\n\nL[7]\n\nL[-8]\n\nL[5][2]"},{"metadata":{"trusted":true},"cell_type":"code","source":"","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Extraction de sous-liste, saucissonage (slicing)\n\n\nIl est possible de récupérer une sous-liste d'une liste à l'aide d'une méthode dite d'extraction (ou de __slicing__). \n\n_sous_liste=liste[début:fin]\n\nOù _début_ est un entier correspondant à l'indice à partir duquel on extrait une sous-liste et _fin_ un entier correspondant à l'indice de fin __exclu__\n\nAinsi si _liste = [1,2,3,4,5,6,7,8]_ , alors\n\n_liste[0:2]_ contient la sous-liste commençant à l'indice 0 jusqu'à l'indice 2 exclu donc il s'agit de _[1,2]_\n\nIl est possible de préciser un pas (qui correspond à l'écart entre deux indices successifs lors de l'extraction) avec la syntaxe _liste[début:fin:pas]_ . Un pas de 2 revient à ne prendre qu'un élément sur 2, un pas de 3 qu'un élément sur 3, etc...\n\n_liste[1:5:3]_ contiendra donc [2,5] (la sous-liste de l'indice 1 inclu à 5 exclu en comptant de 3 en 3). \n\nDans le cas d'indices négatifs, on parcourt la liste à l'envers. Ainsi _liste[4:0:-1]_ contiendra _[5,4,3,2]_ (la sous-liste qui commence à l'indice 4 inclu à 0 exclu en parcourant les indices de -1 en -1.\n\n#### Exemples d'application\n\nOn exécute tout d'abord l'instruction _liste = [1,2,3,4,5,6,7,8,9,10]_\nPrévoir et vérifier ce que renvoient les slicings :\n\n- liste[2:6:2]\n- liste[2:6:-2]\n- liste[6:2:2]\n- liste[6:2:-2]\n- liste[2:6]\n- liste[6:2]\n\nEt interpréter ce qui se passe avec les instructions \nliste[:6] et liste[6:]\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = [1,2,3,4,5,6,7,8,9,10]\n# A compléter \n","execution_count":11,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"## Modification d'une liste\n\nOn a vu comment créer une liste et comment extraire une sous-liste. Il est également possible de modifier une liste soit\n\n1. En ajoutant un élément à la fin (déjà évoqué dans la méthode 2 de création d'une liste)\n2. En modifiant un élément déjà présent. Dans ce cas, la syntaxe est _liste[indice] = nouvelle_valeur_ \n\nOn illustre le fonctionnement en modifiant une liste en y ajoutant successivement des éléments :"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = []\nfor i in range(10):   # On parcourt les entiers de 0 à 9\n    liste += [i+1] # et on ajoute cet entier +1 à la liste\nprint(liste)","execution_count":12,"outputs":[{"output_type":"stream","text":"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"Désormais on peut accéder à n'importe quel élément d'indice entre 0 et 9 mais pas au délà de 9 (on peut aussi accéder aux indices négatifs, comptés en partant de la fin de la liste)."},{"metadata":{"trusted":true},"cell_type":"code","source":"print(liste[9])\nprint(liste[10])","execution_count":13,"outputs":[{"output_type":"stream","text":"10\n","name":"stdout"},{"output_type":"stream","text":"Traceback (most recent call last):\n  File \"<input>\", line 2, in <module>\nIndexError: list index out of range\n","name":"stderr"}]},{"metadata":{},"cell_type":"markdown","source":"On peut donc si on le souhaite __modifier__ les éléments de la liste (on va par exemple les incrémenter de 2). En revanche notons que comme l'appel à _liste[10]_ renvoie une erreur, il n'est pas possible de placer une valeur en dernière position avec cette syntaxe. __Il faut obligatoirement utiliser la méthode précédente pour ajouter des éléments à une liste__."},{"metadata":{"trusted":true},"cell_type":"code","source":"for i in range(10):\n    liste[i] = liste[i] + 2 # On ajoute 2 à l'élément à la position i et on se sert du résultat \n                            # pour remplacer l'ancienne valeur\nprint(liste)","execution_count":14,"outputs":[{"output_type":"stream","text":"[3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"##### Exemples d'application\n\nOn se donne la liste : _liste = ['Mardi','Mercrecrecredi','Jeudi']_\n\n1. Créer une liste _liste_3_jours_ à partir de _liste_ qui ne présente plus de faute de frappe.\n2. Créer une liste _liste_7_jours_ à partir de _liste_3_jours_ qui contienne les jours d'une semaine complète\n3. Quelle est l'instruction permettant d'obtenir la liste ['Mardi','Jeudi','Samedi'] à partir de _liste_7_jours_ par __slicing__."},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = ['Mardi','Mercrecrecredi','Jeudi']\n# A compléter","execution_count":15,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"# Définition création et extraction des tuple\n\nUn _n_ -uplet, ou tuple en anglais, est une séquence qui contient une série de valeurs. Python autorise la construction de tuple contenant des valeurs de types différents (par exemple entier et chaîne de caractères), ce qui leur confère une certaine flexibilité. Un tuple est déclarée par une série de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de chaînes de caractères) séparées par des virgules, et le tout encadré par des parenthèses.\n\nExemple :"},{"metadata":{"trusted":true},"cell_type":"code","source":"exemple_tuple = ('Bonjour',4,None,True,5.2)","execution_count":16,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Les tuple ressemblent en tous points aux listes, à ceci près qu'ils ne sont pas modifiables (on dit également non mutables ou immuables).\n\nRemarquez l'erreur générée lorsqu'on essaie de modifier un tuple"},{"metadata":{"trusted":true},"cell_type":"code","source":"exemple_tuple[3] = 2","execution_count":17,"outputs":[{"output_type":"stream","text":"Traceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n","name":"stderr"}]},{"metadata":{},"cell_type":"markdown","source":"_Question légitime_ : Mais à quoi ça sert ?\n\nEn réalité lorsqu'une fonction (c.f. notebook fonctions) renvoie plusieurs valeurs (séparées par des variables), l'objet contenant le résultat est un tuple, il faut donc savoir que celà existe pour ne pas le traiter comme une liste:"},{"metadata":{"trusted":true},"cell_type":"code","source":"def fonction_inutile(x):\n    assert type(x) == int or type(x) == float # cf notebook fonctions, une erreur est retournée si l'argument\n    # de la fonction n'est pas un nombre\n    return x+1,x-1 # La fonction renvoie une paire de nombres : x+1 et x-1\n\nrésultat = fonction_inutile(4)\nprint(résultat)\nprint(type(résultat))","execution_count":18,"outputs":[{"output_type":"stream","text":"(5, 3)\n<class 'tuple'>\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"Mais même si ces objets ne sont pas mutables, on peut quand même en extraire le contenu (éventuellement par slicing):"},{"metadata":{"trusted":true},"cell_type":"code","source":"print(résultat[1]) # extraction du second élément (d'indice 1)","execution_count":19,"outputs":[{"output_type":"stream","text":"3\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"# Pour aller plus loin : mutabilité et immuabilité\n\nLa question de la mutabilité donne lieu à quelques fonctionnements 'exotiques' auxquels il faut être sensible pour comprendre certains bugs étranges (même si le programme n'exige pas de compréhension approfondie de ces phénomènes).\n\nLorsqu'une variable est déclaré d'un l'ordinateur, celle-ci est placée dans une case mémoire de l'ordinateur qui a une certaine adresse (unique). On peut demander à python cette adresse avec l'instruction __id(nom_variable)__"},{"metadata":{"trusted":true},"cell_type":"code","source":"a = 4\nprint(id(a)) # L'adresse mémoire où est placée la variable a","execution_count":20,"outputs":[{"output_type":"stream","text":"3005440\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"Chaque variable a son adresse et lorsqu'on change la valeur d'une variable non mutable, puisqu'on ne peut pas la modifier, Python va tout simplement choisir une nouvelle adresse mémoire pour contenir cette variable :"},{"metadata":{"trusted":true},"cell_type":"code","source":"a = 4 # Ca ne fait rien on n'a pas changé le contenu de a\nprint('adresse de a :')\nprint(id(a)) # Ca n'a pas bougé\nb = a # On place le contenu de a dans b, c'est le même donc autant occuper la même case mémoire :\nprint('adresse de b (qui à même valeur que a):')\nprint(id(b))\na = a + 1 # Maintenant on change le contenu, mais les entiers sont immuables donc il faut placer a à une autre adresse :\nprint('adresse de a après modification de sa valeur :')\nprint(id(a))\nprint(\"et celle de b (que l'on a pas changé) :\")\nprint(id(b))","execution_count":21,"outputs":[{"output_type":"stream","text":"adresse de a :\n3005440\nadresse de b (qui à même valeur que a):\n3005440\nadresse de a après modification de sa valeur :\n3005456\net celle de b (que l'on a pas changé) :\n3005440\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"##### Conclusion partielle: lorsqu'on copie une variable immuable (ici avec a = b) les deux variables sont entièrement indépendantes et on peut modifier l'une sans influencer l'autre\n\nMaintenant regardons ce qui se passe pour des objets mutables. On va construire une liste et modifier ses valeurs. Puisque c'est le même objet (dont on ne fait que modifier le contenu), son adresse mémoire ne changera pas :"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = ['salut','les','sups']\nliste_copie = liste\nprint(id(liste)) # jusque là rien de différents avec les objets immuables\nprint(id(liste_copie))\n# on modifie liste\nliste[1] = 'jeunes' # modification de l'élément à l'indice 1\nprint(id(liste))","execution_count":22,"outputs":[{"output_type":"stream","text":"12775368\n12775368\n12775368\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"Modifier un objet mutable ne conduit pas à un changement d'adresse. Mais que se passe-t-il donc pour _liste_copie_ situé à la même adresse ?"},{"metadata":{"trusted":true},"cell_type":"code","source":"print(liste_copie)","execution_count":23,"outputs":[{"output_type":"stream","text":"['salut', 'jeunes', 'sups']\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"##### Conclusion : lorsqu'on copie une variable mutable (ici avec liste_copie = liste) , modifier l'un des deux objets va conduire à une modification de l'autre objet.\n\nSi l'on souhaite copier la liste en évitant ce phénomène de modification de la copie, il est nécessaire de recopier chacun des éléments de la liste un à un :"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = ['salut','les','sups']\nliste_copie = [mot for mot in liste]\nprint(id(liste))\nprint(id(liste_copie))","execution_count":24,"outputs":[{"output_type":"stream","text":"8922896\n14386640\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"#### Subtilité (fourberie en réalité)\n\nOn a vu que les modifications _L[i]=valeur_ n'engendrent pas de changement de l'adresse mémoire pour _L_. C'est également le cas pour la méthode .append() et la concaténation avec += :"},{"metadata":{"trusted":true},"cell_type":"code","source":"liste = [0]\nprint(id(liste))\nliste += [1]\nprint(id(liste))\nliste.append(2)\nprint(id(liste))\nliste = liste + [3]\nprint(id(liste))","execution_count":25,"outputs":[{"output_type":"stream","text":"13718720\n13718720\n13718720\n12785256\n","name":"stdout"}]},{"metadata":{},"cell_type":"markdown","source":"Donc la structure _liste += liste2_ ne modifie pas l'adresse de _liste_, en revanche _liste = liste + liste2_ la modifie. L'expression += dans le contexte des listes est en réalité un alias sur la méthode .append(...) et non pas une version abrégée de _liste = liste + ..._ comme on aurait pu l'imaginer."}],"metadata":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"}},"nbformat":4,"nbformat_minor":2}